import { ApiTags } from '@nestjs/swagger';
import { BadRequestException, Controller, Get, Header, Headers, Post, Req, Res, UploadedFile, UseInterceptors } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { createReadStream, createWriteStream, statSync, unlinkSync } from 'fs';
import { diskStorage } from 'multer';
import { ProfileService } from '../application/profile.service';
import { HttpService } from '@nestjs/axios';
import { mkdir } from 'fs/promises';
import { FileValidationPipe } from '../../../../../libs/check.file';
import { join } from 'path';
import { lastValueFrom } from 'rxjs';


@ApiTags('Profile')
@Controller('profile')
export class ProfileController {
  private readonly uploadsDir = './tmp/chunks';
  private readonly localFileName = 'test.png';
  constructor(
    readonly profileService: ProfileService,
    private readonly httpService: HttpService,

  ) {
    mkdir(this.uploadsDir, { recursive: true });
  }

  @Get('send')
  async sendMessage() {
    await this.profileService.sendMessage()
  }

  @Post('localSave')
  @UseInterceptors(FileInterceptor('file', {
    storage: diskStorage({
      destination: './tmp',
      filename: (req, file, cb) => {
        cb(null, `${Date.now()}-${file.originalname}`);
      },
    }),
  }))
  async uploadStream(@UploadedFile() file: Express.Multer.File) {
    await this.profileService.localSaveFile(file)
  }

  @Post()
  @UseInterceptors(FileInterceptor('file', {
    storage: diskStorage({
      destination: './tmp',
      filename: (req, file, cb) => cb(null, file.originalname),
    }),
  }))
  async uploadFile(
    @Req() req,
    @UploadedFile(new FileValidationPipe()) file: Express.Multer.File,
  ) {
    if (!file) throw new BadRequestException({
      message: 'Not a valid file'
    })
    console.log(file)
    // const writeStream = createWriteStream(`./tmp/${file.originalname}`, { highWaterMark: 10000 });

    try {
      //   // 2. –ß–∏—Ç–∞–µ–º —Ñ–∞–π–ª –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –∑–∞–ø–∏—Å–∏
      const readStream = createReadStream(`./tmp/${file.originalname}`);

      //   // 3. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–∞–π–ª
      const response = await this.httpService.post(
        'http://localhost:3795/receive',
        readStream,
        {
          headers: {
            'Content-Type': file.mimetype,
            'X-Filename': file.originalname,
          },
        }
      ).toPromise();

      return response.data;
    } catch (error) {
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
      console.error('–û—à–∏–±–∫–∞:', error.message);
      throw error;
    } finally {
      // 4. –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
      unlinkSync(`./tmp/${file.originalname}`);
    }

  }


  @Post('chunk')
  // @UseInterceptors(FileInterceptor('file'))
  async uploadFileChunk(


  ) {
    const filePath = `./tmp/${this.localFileName}`; // üìå –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É
    const fileStats = statSync(filePath);
    const totalSize = fileStats.size;
    const chunkSize = 16 * 1024; // 16 KB
    const totalChunks = Math.ceil(totalSize / chunkSize);
    // const fileId = Date.now().toString(); // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Ñ–∞–π–ª–∞
    const fileId = '111111111';
    console.log(`üöÄ –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É: ${filePath}`);
    console.log(`üì¶ –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: ${totalSize} bytes, –ß–∞–Ω–∫–æ–≤: ${totalChunks}`);

    for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
      const start = chunkIndex * chunkSize;
      const end = Math.min(start + chunkSize, totalSize);

      const fileStream = createReadStream(filePath, { start, end: end - 1 });

      try {
        await lastValueFrom(
          this.httpService.post('http://localhost:3795/receive-chunks', fileStream, {
            headers: {
              'Content-Type': 'application/octet-stream',
              'x-file-id': fileId,
              'x-chunk-index': chunkIndex,
              'x-total-chunks': totalChunks,
            },
            maxBodyLength: Infinity,
            maxContentLength: Infinity,
          }),
        );
        console.log(`‚úÖ –ß–∞–Ω–∫ ${chunkIndex + 1}/${totalChunks} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω`);
      } catch (error) {
        console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —á–∞–Ω–∫–∞ ${chunkIndex + 1}:`, error.message);
        return;
      }
    }

    console.log('üîÑ –í—Å–µ —á–∞–Ω–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –Ω–∞ —Å–±–æ—Ä–∫—É —Ñ–∞–π–ª–∞...');
    await this.mergeFile(fileId, this.localFileName);
  }

  private async mergeFile(fileId: string, fileName: string) {
    try {
      await lastValueFrom(
        this.httpService.post('http://localhost:3795/receive-chunks-merge', { fileId, fileName }),
      );
      console.log('‚úÖ –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Å–æ–±—Ä–∞–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ!');
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±–æ—Ä–∫–µ —Ñ–∞–π–ª–∞:', error.message);
    }
  }
}